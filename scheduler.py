import pandas as pd
import combiner
from typing import List
import matplotlib.colors as mcolors
import random

class Schedule(pd.DataFrame):
    # generate this time series only once, since it's shared by all instances
    color_dict = {}
    colors_list = list(mcolors.TABLEAU_COLORS.values())
    def __init__(self, freq : str='15T'):
        time_series = pd.date_range(start='07:00', end='23:00', freq=freq).time
        super().__init__('', index=time_series, columns= list(combiner.weekdays_list))

    def add_course_block(self, course_block: combiner.CourseBlock, repr_str: str) -> None:
        self.loc[course_block.start_time : course_block.end_time, course_block.weekday].iloc[:-1] = repr_str
        if repr_str not in self.color_dict.keys():
            if len(self.colors_list) == 0: # reset colors if we run out of them
                self.colors_list = list(mcolors.TABLEAU_COLORS.values())
            chosen_color = random.choice(self.colors_list)
            self.colors_list.remove(chosen_color)
            self.color_dict[repr_str] = chosen_color

    def add_combination(self, subjects: List[combiner.Subject], combination: combiner.Combination) -> None:
        for subject, comission in zip(subjects, combination):
            sub_name = subject.name
            for block in comission.block_list:
                self.add_course_block(block, f"{sub_name} {comission.identifyer}")

    def apply_format(self):
        # format index
        self.index = self.index.map(lambda t: t.strftime('%H:%M'))
        # color inner cells first
        def color_func(value):
            return f'background-color: {self.color_dict.get(value, "white")}; border: 1px solid grey;'
        return self.style.applymap(color_func)



def save_to_excel(subjects: List[combiner.Subject], combinations: List[combiner.Combination], filepath: str):
    """
    This function saves a list of combinations to a single Excel file
    """

    with pd.ExcelWriter(filepath) as writer:
        for index, combination in enumerate(combinations):
            # add the current combination to a new schedule
            df = Schedule()
            df.add_combination(subjects, combination)

            # make a copy for iterability, and apply format
            copy_df = df.copy()
            df = df.apply_format()

            # add to a new sheet, and auto-adjust columns width
            df.to_excel(writer, sheet_name=f"Combination {index + 1}", engine='xlsxwriter')
            for column in copy_df:
                column_width = max(copy_df[column].astype(str).map(len).max(), len(column))
                col_idx = df.columns.get_loc(column) + 1
                writer.sheets[f"Combination {index + 1}"].set_column(col_idx, col_idx, column_width)


def test_scheduler():
    """
    to test the schedule maker, the combinations generated by the combiner test
    will be used as an example
    """

    subjects, combinations = combiner.test_combiner()
    save_to_excel(subjects, combinations, 'combinations.xlsx')


if __name__ == '__main__':
    test_scheduler()



